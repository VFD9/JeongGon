// Vector v0.1
#include <iostream>

using namespace std;

// 2의 보수

int main(void)
{
	/*
	char n = 127;
	n += 1;
	printf_s("%d", n);

	** +연산과 -연산중 무엇이 더 효율적일까
	char n = 16;
	n += -6;
	n -= 6;

	** 나누기를 해야 할 떄에는 * 기로 대체할 수 있는지 확인해보고
	int n = 1920 / 2;
	// int n = 1920 / 0.5f;
	printf_s("%d", n);

	** 아래와 같이 shift 연산자로 사용할 수 있는지 확인해보자.
	printf_s("%d", n >> 1);
	*/

	/*
	//** 배열은 0이 아닌 값으로만 초기화가 가능하다.
	//** 배열은 상수값으로만 초기화가 가능하다.

	//** 아래와 같이 사용한다면 위 조건은 무시할 수 있다.

	int Size = 0;
	int iter = 0;
	배열의 동적할당에는 0도 들어가고 변수도 들어간다.
	배열을 직접 정하는게 아니고 배열처럼 사용해 크기만 전달하기에 가능하다.
	int* Vector = new int[Size];
	Vector[iter];
	*/

	// 배열은 아니지만 배열처럼 사용할 수 있다.
	int Size = 10;
	int iter = 0;
	int* Vector = new int[Size];

	for (int i = 0; i < Size; ++i)
		Vector[i] = i;

	for (int i = 0; i < 11; ++i)
		cout << Vector[iter++] << endl;

	return 0;
}

// 배열의 특징
/*
	장점
	1. 직접 접근이 가능하다.
	2. 데이터가 나열되어서 접근 속도가 일정하다.
	3. 데이터나 텍스처를 불러오기 좋다.

	단점
	1. 배열의 동적 변환이 불가능하다.(길이가 정해지면 바꿀 수 없다)
	2. 데이터를 어디에 뒀는지 알 수 없다.
	3. 오브젝트를 담기에는 비효율적이기에 사용하지 않는다.
*/

// 이동이 복제보다 빠르다.

	// ** 1. 데이터 추가 (새로운 공간 확보)
	// ** 2. 데이터 삭제
	// ** 3. 데이터를 삽입할 수 있는 공간의 크기
	// ** 4. 현재 삽입되어있는 원소의 개수
	// ** 5. 컨테이너의 시작 지점
	// ** 6. 컨테이너의 종료 지점